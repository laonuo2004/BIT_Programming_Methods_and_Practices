#include <iostream>
#define MAXN 200000
using namespace std;

int main()
{
	int n;
	while (cin >> n)
	{
		int temp;
		int stack[MAXN] = { 0 };
		int top = 0;
		for (int i = 0; i < n; ++i)
		{
			cin >> temp;
			temp &= 1;
			if(!top || stack[top - 1] != temp)
				stack[top++] = temp;
			else
				--top;
		}
		cout << (top > 1 ? "NO" : "YES") << endl;
	}
	return 0;
}

/*
* 思路：我们先假设石头只能竖着放，由于石头高度为2，因此原来是奇数高度的，只能是奇数高度；原来是偶数高度的，只能是偶数高度。最理想的情况就是奇偶高度相差1，因此我们将高度全部&1，转变为0-1串，这便是第一阶段。
* 随后，我们让石头可以横着放，这样就可以填平奇偶高度相差的1。但是如果要横着放，必须要有连续两块相等高度的区域，于是我们就用到了栈。我们从左到右遍历每一块区域的高度，如果栈顶元素与当前元素的高度相等，那么我们就可以将栈顶元素弹出，表示这两块用一个横着的石头填平了；否则我们就将当前元素压入栈中。
* 你可能会好奇，这样处理的话，原来不连续的两块相等高度的区域似乎也能被弹出来，这该如何理解？可以尝试一下这个情况：[1,0,1,0,0,1,0,1]。我们从左往右模拟，中间两个0会被我们填平，这时中间便有4个连续的1，我们可以在上面不停地横着放石头，可以使之到达任意高度，这样它们是永远平整的。这在栈里是如何体现的呢？其实就是中间两个0被弹出了之后，再入栈原来的第6个1，它与第3个1相等，继续弹出。这样一来，弹出与填平就是等价的了，与连续与否无关。
* 最后判断能否填平的条件是栈中元素个数是否为0或1，如果是，那么就可以填平，否则就不能。
*/